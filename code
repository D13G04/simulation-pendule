from math import *
import pygame as pg
import tkinter as tk
import os

from pygame.math import Vector2


class SurfaceRotated(pg.sprite.Sprite):   
    def __init__(self, pos, L, r1, r2, A, L1, L2, rayon_barre, rayon1, rayon2, coef_conv, const_angle_pendule, d, R):
        super().__init__()
        self.image = pg.Surface((L*coef_conv, 70), pg.SRCALPHA)
        self.tige_surface = pg.draw.rect(self.image, (0,0,0), ((0,70/2-rayon_barre*coef_conv),(L*coef_conv,2*rayon_barre*coef_conv +2)) )
        self.m1_surface = pg.draw.rect(self.image, (255,0,200), ((L*coef_conv/2 + r1*coef_conv - L1*coef_conv/2, 70/2 - rayon1*coef_conv),(L1*coef_conv, 2*rayon1*coef_conv +2))) 
        self.m2_surface = pg.draw.rect(self.image, (0,255,0), ((L*coef_conv/2 + r2*coef_conv - L2*coef_conv/2, 70/2 - rayon2*coef_conv),(L2*coef_conv, 2*rayon2*coef_conv +2))) 
        # A reference to the original image to preserve the quality.
        self.orig_image = self.image
        self.rect = self.image.get_rect(center=pos)
        self.pos = Vector2(pos)  # The original center position/pivot point.
        self.offset = Vector2(-(R - d)*coef_conv, 0)  # We shift the sprite 50 px to the right.
        self.angle = const_angle_pendule + A

    def update(self, pos, w, tick, const_angle_pendule, isOn, currentTick, L, r1, r2, A, L1, L2, rayon_barre, rayon1, rayon2, coef_conv):
        self.image = pg.Surface((L*coef_conv, 70), pg.SRCALPHA)
        self.orig_image = self.image
        self.rect = self.image.get_rect(center=pos)
        self.tige_surface = pg.draw.rect(self.image, (0,0,0), ((0,70/2-rayon_barre*coef_conv),(L*coef_conv,2*rayon_barre*coef_conv +2)) )
        self.m1_surface = pg.draw.rect(self.image, (255,0,200), ((L*coef_conv/2 + r1*coef_conv - L1*coef_conv/2, 70/2 - rayon1*coef_conv),(L1*coef_conv, 2*rayon1*coef_conv +2))) 
        self.m2_surface = pg.draw.rect(self.image, (0,255,0), ((L*coef_conv/2 + r2*coef_conv - L2*coef_conv/2, 70/2 - rayon2*coef_conv),(L2*coef_conv, 2*rayon2*coef_conv +2))) 
        if isOn:
            self.angle = abs(A) * sin(w*(tick - currentTick)/1000 + A * pi/180) - const_angle_pendule
            self.rotate()
        else:
            self.angle = -const_angle_pendule + A
            self.rotate()

    def rotate(self):
        """Rotate the image of the sprite around a pivot point."""
        # Rotate the image.
        self.image = pg.transform.rotozoom(self.orig_image, -self.angle, 1)
        # Rotate the offset vector.
        offset_rotated = self.offset.rotate(self.angle)
        # Create a new rect with the center of the sprite + the offset.
        self.rect = self.image.get_rect(center=self.pos+offset_rotated)
        
class Main(): 

    def __init__(self):
        self.titlePg = "Pendule simulation"
        self.fps = 60

        self.screen = tk.Tk()

        self.screen_width = self.screen.winfo_screenwidth() 
        self.screen_height = self.screen.winfo_screenheight()

    def new(self):
        #Nouvelles instances pour chaques nouvelles parties 
        pg.init()
        pg.display.set_caption(self.titlePg) 
        self.window = pg.display.set_mode((0,0), pg.FULLSCREEN)

        # self.screen.geometry("{}x{}+{}+{}".format(self.window_width, self.window_height, self.x_cordinate, self.y_cordinate))

        self.font = pg.font.SysFont("arial", 30)
        self.clock = pg.time.Clock()

        self.coef_conv = 1500
        self.const_angle_pendule = 90

        self.angle = 0
        self.g = 9.81
        self.A = 40
        self.L = 0.1905*2
        self.r1 = -0.12
        self.r2 = 0.0
        self.m1 = 0.08015
        self.m2 = 0.08015
        self.M = 0.041  #masse de la barre
        self.R = self.L/2 
        self.rayon1 = 0.013  #rayon de la masse 1
        self.rayon2 = 0.013  #rayon de la masse 2
        self.rayon_barre = 0.005
        self.L1 = 0.025  #hauteur de la masse 1
        self.L2 = 0.025  #hauteur de la masse 2
        self.d = self.R  #distance du pivot depuis un côté de la tige
        
        self.Ibarre = (self.M * self.rayon_barre**2 / 4) + (self.M * self.R**2 /3) + self.M*(self.R-self.d)**2
        self.I1 = (self.m1 * self.rayon1**2 / 4) + (self.m1 * self.L1**2 /12) + self.m1*(self.r1 + self.R - self.d)**2
        self.I2 = (self.m2 * self.rayon2**2 / 4) + (self.m2 * self.L2**2 /12) + self.m2*(self.r2 + self.R - self.d)**2
        self.I = self.Ibarre + self.I1 + self.I2
        self.w = sqrt(abs((self.r2 + self.R - self.d)*self.m2 + (self.r1 + self.R - self.d)*self.m1 + self.M*(self.R - self.d)) * self.g / self.I)
        
        self.pivot_pos = (self.screen_width/2, self.screen_height/2 - (self.R - self.d)*self.coef_conv)

        self.T = sqrt(self.I * 4*pi**2 / abs((self.M*(self.R-self.d) + self.m1*(self.r1 +(self.R-self.d) + self.r2 +(self.R-self.d))))/self.g)


        self.surface_rotated = SurfaceRotated(self.pivot_pos, self.L, self.r1, self.r2, self.A, self.L1, self.L2, self.rayon_barre, self.rayon1, self.rayon2, self.coef_conv, self.const_angle_pendule, self.d, self.R)
        self.all_sprites = pg.sprite.Group(self.surface_rotated)

        self.show_r1_rect = pg.Rect(100, self.screen_height*3/30 + 2*32, 150, 40)
        self.show_r1Surface = pg.Surface((self.show_r1_rect[2], self.show_r1_rect[3]))

        self.OnOff_rect = pg.Rect(100, self.screen_height*3/10 + 2*32, 150, 40)
        self.OnOffSurface = pg.Surface((self.show_r1_rect[2], self.show_r1_rect[3]))

        self.isON = False
        self.colorON = (255,0,0)
        self.colorOFF = (0,255,0)
        self.currentColor = self.colorOFF

        self.currentTick = 0
        
        self.run()
        
        pg.quit()


    def run(self):
        # Boucle du jeu
        self.playing = True
        while self.playing:
            self.tick = pg.time.get_ticks()
            self.clock.tick(self.fps) # définie les fps en fonction self.fps
            self.event()
            self.update()
            self.draw()
        
    def update(self):
        self.Ibarre = (self.M * self.rayon_barre**2 / 4) + (self.M * self.R**2 /3) + self.M*(self.R-self.d)**2
        self.I1 = (self.m1 * self.rayon1**2 / 4) + (self.m1 * self.L1**2 /12) + self.m1*(self.r1 + self.R - self.d)**2
        self.I2 = (self.m2 * self.rayon2**2 / 4) + (self.m2 * self.L2**2 /12) + self.m2*(self.r2 + self.R - self.d)**2
        self.I = self.Ibarre + self.I1 + self.I2
        self.w = sqrt(abs((self.r2 + self.R - self.d)*self.m2 + (self.r1 + self.R - self.d)*self.m1 + self.M*(self.R - self.d)) * self.g / self.I)

        self.T = sqrt(self.I * 4*pi**2 / abs((self.M*(self.R-self.d) + self.m1*(self.r1 +(self.R-self.d) + self.r2 +(self.R-self.d))))/self.g)
        
        print(self.T)

        self.all_sprites.update(self.pivot_pos, self.w, self.tick, self.const_angle_pendule, self.isON, self.currentTick, self.L, self.r1, self.r2, self.A, self.L1, self.L2, self.rayon_barre, self.rayon1, self.rayon2, self.coef_conv)
    def event(self):
        for event in pg.event.get():
            if event.type == pg.QUIT:
                self.playing = False
            if event.type == pg.KEYDOWN:
                if not self.isON:
                    if event.key == pg.K_d:
                        self.A -= 5 
                        if self.A < -180 :
                            self.A = 180 - abs(self.A)%180
                    if event.key == pg.K_a:
                        self.A += 5
                        if self.A > 180 :
                            self.A = -180 + self.A%180
                if event.key == pg.K_RIGHT:
                    self.r1 += 0.01
                if event.key == pg.K_LEFT:
                    self.r1 -= 0.01
            if event.type == pg.MOUSEBUTTONDOWN:
                if self.OnOff_rect.collidepoint(event.pos):
                    self.isON = not self.isON
                    if self.currentColor == self.colorOFF:
                        self.currentColor = self.colorON
                        self.currentTick = self.tick
                    else:
                        self.currentColor = self.colorOFF
                        self.currentTick = self.tick
            
    def draw(self):
        self.window.fill((255,255,255))
        self.all_sprites.draw(self.window)
        pg.draw.circle(self.window, (255, 128, 0), [int(i) for i in self.surface_rotated.pos], 3)
        
        self.show_r1Surface.fill((200,200 ,255))
        self.window.blit(self.show_r1Surface, (self.show_r1_rect[0], self.show_r1_rect[1]))
        self.show_r1Text = self.font.render("r1 = " + str((self.r1 + self.d -self.R)*100) + " cm" , True, (0,0,0))
        self.window.blit(self.show_r1Text, (self.show_r1_rect[0]+5, self.show_r1_rect[1]+5))

        self.OnOffSurface.fill(self.currentColor)
        self.window.blit(self.OnOffSurface, (self.OnOff_rect[0]+5, self.OnOff_rect[1]+5))
      
        pg.display.flip()


w = Main()
w.new()
